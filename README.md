## Домашнее задание на микросервисы


Сделаны все пункты задания (есть нюансы, которые описаны в конце). 

Текста может много(извините), но это должно ускорить понимание достаточно большой структуры проекта.

---

Все примеры запросов есть в коллекциях postman в корне данной директории ([Auth_collection.json](Auth_collection.json)) и ([Order_handler_collection.json](Order_handler_collection.json))

После авторизации, JWT отправляется на сервер в заголовке Authorization в формате "Bearer <\token>".

Сервисы выполнены как полноценные микросервисы и могут быть запущены отдельно друг от друга, даже на разных машинах.

---

### Запуск
Для запуска сервисов необходимо выполнить команду `docker-compose up --build` в корне данной директории.

! Стоит отметить, что для работы есть файлы с переменными среды, которые естественно не должны быть в репозитории, но для демонстрации домашней работы, они оставлены.

Будут созданы контейнеры, volumes, а также сети для микросервисов (подробнее можно посмотреть в [docker-compose.yml](docker-compose.yml)).

--- 
### Структура микросервисов

Все запросы настраивает сконфигурированный nginx, который также запущен в виде docker контейнера и подключен к обоим сетям микросервисов. Микросервисы могу быть легко масштабируемы, а nginx просто их связывает для удобства доступа.

Субд и места хранения (volume) для каждого сервиса свои, что позволяет добиться изоляции сервисов друг от друга.

#### Auth (изолированный микросервис)
Состоит из django контейнера и postgresql контейнера.

#### Order handler (изолированный микросервис)
Состоит из django контейнера, postgresql контейнера(второго, а не такого-же как в Auth), брокера сообщений redis (также в docker), а также Worker, который по заданию должен по расписанию изменять статусы заказов.

То есть в redis записываются сообщения, которые потом обрабатывает Worker и изменяет статусы заказов.

--- 
### Структура директорий

#### Сервис(папка) Auth_service
- [./Auth_service](Auth_service%2FAuth_service) - настройки django проекта
- [./api_app](Auth_service%2Fapi_app) - само приложение django
- [./api_app/models](Auth_service%2Fapi_app%2Fmodels) - модуль, содержащий модели для работы с бд
- [./api_app/serializers.py](Auth_service%2Fapi_app%2Fserializers.py) - модуль, содержащий сериализаторы для моделей и последующей работы с ними в представлениях views 
- [./api_app/urls.py](Auth_service%2Fapi_app%2Furls.py) - Файл, содержащий маршруты для обработки запросов 
- [./api_app/views.py](Auth_service%2Fapi_app%2Fviews.py) - Файл, содержащий логику обработки запросов
- [.django_entrypoint.sh](Auth_service%2Fdjango_entrypoint.sh) - Файл, использующийся для ожидания запуска postgresql и миграций
- [api_dockerfile](Auth_service%2Fapi_dockerfile) - Файл, содержащий инструкции для сборки контейнера django
- [.api_env](Auth_service%2F.api_env) и [.database_env](Auth_service%2F.database_env) - файлы с переменными среды для django и postgresql соответственно (которые должны быть локально, но для демонстрации оставлены) 

#### Сервис(папка) Order_handler_service
- [./Order_handler_service](Order_handler_service%2FOrder_handler_service) - настройки django проекта
- [./Order_handler_service/celery.py](Order_handler_service%2FOrder_handler_service%2Fcelery.py) - Файл, содержащий настройки асинхронных задач для Redis для библиотеки celery
- [./api_app](Order_handler_service%2Fapi_app) - Папка с приложением django
- [./api_app/models](Order_handler_service%2Fapi_app%2Fmodels) - модуль, содержащий модели для работы с бд
- [./api_app/serializers](Order_handler_service%2Fapi_app%2Fserializers.py) - модуль, содержащий сериализаторы для моделей и последующей работы с ними в представлениях views
- [./api_app/urls.py](Order_handler_service%2Fapi_app%2Furls.py) - Файл, содержащий маршруты для обработки запросов
- [./api_app/views](Order_handler_service%2Fapi_app%2Fviews) - Модуль, содержащий логику обработки запросов 
- [./api_app/authentications.py](Order_handler_service%2Fapi_app%2Fauthentications.py) - Файл, содержащий кастомную(написанную мной) аутентификацию для JWT 
- [./api_app/permissions.py](Order_handler_service%2Fapi_app%2Fpermissions.py) - Файл, содержащий кастомные(написанные мной) права доступа для JWT. То есть проверку на менеджера в данном случае.
- [./api_app/tasks.py](Order_handler_service%2Fapi_app%2Ftasks.py) - Файл, содержащий асинхронную задачу для изменения статуса заказа. (Кстати запросы к бд оптимизированы и проходят за два запроса, а не за n запросов).

#### Корневая папка
- [.shared_api_env](.shared_api_env) - Файл, содержащий переменные среды для обоих сервисов. В данном случае лишь секретный ключ для JWT, так как оба сервиса должны шифроваться. (еще раз повторю, что никогда не оставляю такие вещи в репозитории).
- [Auth_collection.json](Auth_collection.json) и [Order_handler_collection.json](Order_handler_collection.json) - Коллекции с примерами запросов
- [docker-compose.yml](docker-compose.yml) - Файл, содержащий инструкции для сборки контейнеров и их запуска. 
- [nginx.conf](nginx.conf) - Файл, содержащий настройки nginx

---

### Нюансы работы (риторические вопросы))

1) Зачем нужна таблица сессии, когда jwt токен не требует бд
2) Как должна быть учтена возможность предоставления различных ролей пользователю? Тогда каждый будет себе админа ставить при регистрации. Я сделал так, что при регистрации пользователь не менеджер. Администратор может сделать его менеджером через встроенную админку django, либо же внутри контейнера сделать superuser в django.
3) Если это действительно микросервисы, то почему в базе данных Order есть связь с таблицей User? Это же нарушение принципов микросервисов, так как это два различных сервиса и базы данных должны быть разделены. Я сделал хранение ID пользователя и его роли в токене, чтобы не делать запрос к базе данных. Это безопасно, так как данные шифруются и не могут быть изменены.
4) Требование django: url обязательно должно заканчиваться на /
